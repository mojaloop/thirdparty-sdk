/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/health': {
    get: operations['HealthGet'];
  };
  '/metrics': {
    get: operations['MetricsGet'];
  };
  '/authorizations': {
    post: operations['OutboundAuthorizationsPost'];
  };
  '/thirdpartyTransaction/partyLookup': {
    post: operations['ThirdpartyTransactionPartyLookup'];
  };
  '/thirdpartyTransaction/{ID}/initiate': {
    post: operations['ThirdpartyTransactionIDInitiate'];
  };
  '/thirdpartyTransaction/{ID}/approve': {
    post: operations['ThirdpartyTransactionIDApprove'];
  };
  '/thirdpartyRequests/transactions/{ID}/authorizations': {
    post: operations['VerifyThirdPartyAuthorization'];
  };
  '/accounts/{fspId}/{userId}': {
    get: operations['GetAccountsByUserId'];
  };
  '/consentRequests/{ID}/validate': {
    patch: operations['OutboundConsentRequestsValidatePatch'];
  };
  '/consentRequests': {
    post: operations['OutboundConsentRequestsPost'];
  };
  '/linking/providers': {
    get: operations['GetProviders'];
  };
}

export interface operations {
  /** The HTTP request GET /health is used to return the current status of the API. */
  HealthGet: {
    responses: {
      200: components['responses']['200'];
      400: components['responses']['400'];
      401: components['responses']['401'];
      403: components['responses']['403'];
      404: components['responses']['404'];
      405: components['responses']['405'];
      406: components['responses']['406'];
      501: components['responses']['501'];
      503: components['responses']['503'];
    };
  };
  /** The HTTP request GET /metrics is used to return metrics for the API. */
  MetricsGet: {
    responses: {
      200: components['responses']['200'];
      400: components['responses']['400'];
      401: components['responses']['401'];
      403: components['responses']['403'];
      404: components['responses']['404'];
      405: components['responses']['405'];
      406: components['responses']['406'];
      501: components['responses']['501'];
      503: components['responses']['503'];
    };
  };
  /** DFSP Requests Authorization of Transaction from the End User */
  OutboundAuthorizationsPost: {
    requestBody: {
      'application/json': components['schemas']['AuthorizationsRequest'];
    };
    responses: {
      200: components['responses']['AuthorizationsResponse'];
      400: components['responses']['400'];
      401: components['responses']['401'];
      403: components['responses']['403'];
      404: components['responses']['404'];
      405: components['responses']['405'];
      406: components['responses']['406'];
      501: components['responses']['501'];
      503: components['responses']['503'];
    };
  };
  /** The HTTP request `POST /thirdpartyTransaction/partyLookup` is used to lookup information regarding the requested Party, defined by `Type`, `ID` and optionally `SubId`. */
  ThirdpartyTransactionPartyLookup: {
    requestBody: {
      'application/json': components['schemas']['ThirdpartyTransactionPartyLookupRequest'];
    };
    responses: {
      200: components['responses']['ThirdpartyTransactionPartyLookupResponse'];
      400: components['responses']['400'];
      401: components['responses']['401'];
      403: components['responses']['403'];
      404: components['responses']['404'];
      405: components['responses']['405'];
      406: components['responses']['406'];
      501: components['responses']['501'];
      503: components['responses']['503'];
    };
  };
  /** The HTTP request `POST /thirdpartyTransaction/{ID}/initiate` is sent to the Switch to initiate a third party request transaction. */
  ThirdpartyTransactionIDInitiate: {
    parameters: {
      path: {
        ID: components['parameters']['ID'];
      };
    };
    requestBody: {
      'application/json': components['schemas']['ThirdpartyTransactionIDInitiateRequest'];
    };
    responses: {
      200: components['responses']['ThirdpartyTransactionIDInitiateResponse'];
      400: components['responses']['400'];
      401: components['responses']['401'];
      403: components['responses']['403'];
      404: components['responses']['404'];
      405: components['responses']['405'];
      406: components['responses']['406'];
      501: components['responses']['501'];
      503: components['responses']['503'];
    };
  };
  /** The HTTP request `POST /thirdpartyTransaction/{ID}/approve` is used to approve a third party transaction . */
  ThirdpartyTransactionIDApprove: {
    parameters: {
      path: {
        ID: components['parameters']['ID'];
      };
    };
    requestBody: {
      'application/json': components['schemas']['ThirdpartyTransactionIDApproveRequest'];
    };
    responses: {
      200: components['responses']['ThirdpartyTransactionIDApproveResponse'];
      400: components['responses']['400'];
      401: components['responses']['401'];
      403: components['responses']['403'];
      404: components['responses']['404'];
      405: components['responses']['405'];
      406: components['responses']['406'];
      501: components['responses']['501'];
      503: components['responses']['503'];
    };
  };
  /** The HTTP request `POST /thirdpartyRequests/transactions/{ID}/authorizations` is used by the DFSP to verify a third party authorization. */
  VerifyThirdPartyAuthorization: {
    parameters: {
      path: {
        ID: components['parameters']['ID'];
      };
    };
    requestBody: {
      'application/json': components['schemas']['ThirdpartyRequestsTransactionsIDAuthorizationsPostRequest'];
    };
    responses: {
      200: components['responses']['ThirdpartyRequestsTransactionsIDAuthzResponse'];
      400: components['responses']['400'];
      401: components['responses']['401'];
      403: components['responses']['403'];
      404: components['responses']['404'];
      405: components['responses']['405'];
      406: components['responses']['406'];
      501: components['responses']['501'];
      503: components['responses']['503'];
    };
  };
  /** The HTTP request `GET /accounts/{fspId}/{userId}` is used to retrieve the list of potential accounts available for linking. */
  GetAccountsByUserId: {
    parameters: {
      path: {
        fspId: components['schemas']['FspId'];
        userId: components['schemas']['AccountAddress'];
      };
    };
    responses: {
      200: components['responses']['AccountsByUserIdResponse'];
      400: components['responses']['400'];
      401: components['responses']['401'];
      403: components['responses']['403'];
      404: components['responses']['404'];
      405: components['responses']['405'];
      406: components['responses']['406'];
      501: components['responses']['501'];
      503: components['responses']['503'];
    };
  };
  /** Used in the authentication phase of account linking. Used by the PISP to pass an OTP on behalf of the user to the DFSP to establish a chain of trust. */
  OutboundConsentRequestsValidatePatch: {
    parameters: {
      path: {
        ID: components['schemas']['CorrelationId'];
      };
    };
    requestBody: {
      'application/json': components['schemas']['ConsentRequestsValidateRequest'];
    };
    responses: {
      200: components['responses']['ConsentRequestsValidateResponse'];
      400: components['responses']['400'];
      401: components['responses']['401'];
      403: components['responses']['403'];
      404: components['responses']['404'];
      405: components['responses']['405'];
      406: components['responses']['406'];
      501: components['responses']['501'];
      503: components['responses']['503'];
    };
  };
  /** A request from a PISP to a DFSP to start the process of delegating consent */
  OutboundConsentRequestsPost: {
    requestBody: {
      'application/json': components['schemas']['ConsentRequestsPostRequest'];
    };
    responses: {
      200: components['responses']['ConsentRequestsResponse'];
      400: components['responses']['400'];
      401: components['responses']['401'];
      403: components['responses']['403'];
      404: components['responses']['404'];
      405: components['responses']['405'];
      406: components['responses']['406'];
      501: components['responses']['501'];
      503: components['responses']['503'];
    };
  };
  /** The HTTP request `GET /linking/providers` is used to retrieve a list of thirdparty enabled DFSP identifiers. */
  GetProviders: {
    responses: {
      200: components['responses']['LinkingProvidersResponse'];
      400: components['responses']['400'];
      401: components['responses']['401'];
      403: components['responses']['403'];
      404: components['responses']['404'];
      405: components['responses']['405'];
      406: components['responses']['406'];
      501: components['responses']['501'];
      503: components['responses']['503'];
    };
  };
}

export interface components {
  parameters: {
    /** The identifier value. */
    ID: string;
  };
  schemas: {
    /** The API data type ErrorCode is a JSON String of four characters, consisting of digits only. Negative numbers are not allowed. A leading zero is not allowed. Each error code in the API is a four-digit number, for example, 1234, where the first number (1 in the example) represents the high-level error category, the second number (2 in the example) represents the low-level error category, and the last two numbers (34 in the example) represent the specific error. */
    ErrorCode: string;
    /** Error description string. */
    ErrorDescription: string;
    /** Extension key. */
    ExtensionKey: string;
    /** Extension value. */
    ExtensionValue: string;
    /** Data model for the complex type Extension. */
    Extension: {
      key: components['schemas']['ExtensionKey'];
      value: components['schemas']['ExtensionValue'];
    };
    /** Data model for the complex type ExtensionList. An optional list of extensions, specific to deployment. */
    ExtensionList: {
      /** Number of Extension elements. */
      extension: components['schemas']['Extension'][];
    };
    /** Data model for the complex type ErrorInformation. */
    ErrorInformation: {
      errorCode: components['schemas']['ErrorCode'];
      errorDescription: components['schemas']['ErrorDescription'];
      extensionList?: components['schemas']['ExtensionList'];
    };
    /** Data model for the complex type object that contains an optional element ErrorInformation used along with 4xx and 5xx responses. */
    ErrorInformationResponse: {
      errorInformation?: components['schemas']['ErrorInformation'];
    };
    /**
     * Below are the allowed values for the enumeration AuthenticationType.
     * - OTP - One-time password generated by the Payer FSP.
     * - QRCODE - QR code used as One Time Password.
     * - U2F - U2F is a new addition isolated to Thirdparty stream.
     */
    AuthenticationType: 'OTP' | 'QRCODE' | 'U2F';
    /** The API data type Integer is a JSON String consisting of digits only. Negative numbers and leading zeroes are not allowed. The data type is always limited to a specific number of digits. */
    Integer: string;
    /** The currency codes defined in [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) as three-letter alphabetic codes are used as the standard naming representation for currencies. */
    Currency:
    | 'AED'
    | 'AFN'
    | 'ALL'
    | 'AMD'
    | 'ANG'
    | 'AOA'
    | 'ARS'
    | 'AUD'
    | 'AWG'
    | 'AZN'
    | 'BAM'
    | 'BBD'
    | 'BDT'
    | 'BGN'
    | 'BHD'
    | 'BIF'
    | 'BMD'
    | 'BND'
    | 'BOB'
    | 'BRL'
    | 'BSD'
    | 'BTN'
    | 'BWP'
    | 'BYN'
    | 'BZD'
    | 'CAD'
    | 'CDF'
    | 'CHF'
    | 'CLP'
    | 'CNY'
    | 'COP'
    | 'CRC'
    | 'CUC'
    | 'CUP'
    | 'CVE'
    | 'CZK'
    | 'DJF'
    | 'DKK'
    | 'DOP'
    | 'DZD'
    | 'EGP'
    | 'ERN'
    | 'ETB'
    | 'EUR'
    | 'FJD'
    | 'FKP'
    | 'GBP'
    | 'GEL'
    | 'GGP'
    | 'GHS'
    | 'GIP'
    | 'GMD'
    | 'GNF'
    | 'GTQ'
    | 'GYD'
    | 'HKD'
    | 'HNL'
    | 'HRK'
    | 'HTG'
    | 'HUF'
    | 'IDR'
    | 'ILS'
    | 'IMP'
    | 'INR'
    | 'IQD'
    | 'IRR'
    | 'ISK'
    | 'JEP'
    | 'JMD'
    | 'JOD'
    | 'JPY'
    | 'KES'
    | 'KGS'
    | 'KHR'
    | 'KMF'
    | 'KPW'
    | 'KRW'
    | 'KWD'
    | 'KYD'
    | 'KZT'
    | 'LAK'
    | 'LBP'
    | 'LKR'
    | 'LRD'
    | 'LSL'
    | 'LYD'
    | 'MAD'
    | 'MDL'
    | 'MGA'
    | 'MKD'
    | 'MMK'
    | 'MNT'
    | 'MOP'
    | 'MRO'
    | 'MUR'
    | 'MVR'
    | 'MWK'
    | 'MXN'
    | 'MYR'
    | 'MZN'
    | 'NAD'
    | 'NGN'
    | 'NIO'
    | 'NOK'
    | 'NPR'
    | 'NZD'
    | 'OMR'
    | 'PAB'
    | 'PEN'
    | 'PGK'
    | 'PHP'
    | 'PKR'
    | 'PLN'
    | 'PYG'
    | 'QAR'
    | 'RON'
    | 'RSD'
    | 'RUB'
    | 'RWF'
    | 'SAR'
    | 'SBD'
    | 'SCR'
    | 'SDG'
    | 'SEK'
    | 'SGD'
    | 'SHP'
    | 'SLL'
    | 'SOS'
    | 'SPL'
    | 'SRD'
    | 'STD'
    | 'SVC'
    | 'SYP'
    | 'SZL'
    | 'THB'
    | 'TJS'
    | 'TMT'
    | 'TND'
    | 'TOP'
    | 'TRY'
    | 'TTD'
    | 'TVD'
    | 'TWD'
    | 'TZS'
    | 'UAH'
    | 'UGX'
    | 'USD'
    | 'UYU'
    | 'UZS'
    | 'VEF'
    | 'VND'
    | 'VUV'
    | 'WST'
    | 'XAF'
    | 'XCD'
    | 'XDR'
    | 'XOF'
    | 'XPF'
    | 'YER'
    | 'ZAR'
    | 'ZMW'
    | 'ZWD';
    /** The API data type Amount is a JSON String in a canonical format that is restricted by a regular expression for interoperability reasons. This pattern does not allow any trailing zeroes at all, but allows an amount without a minor currency unit. It also only allows four digits in the minor currency unit; a negative value is not allowed. Using more than 18 digits in the major currency unit is not allowed. */
    Amount: string;
    /** Data model for the complex type Money. */
    Money: {
      currency: components['schemas']['Currency'];
      amount: components['schemas']['Amount'];
    };
    /** Identifier that correlates all messages of the same sequence. The API data type UUID (Universally Unique Identifier) is a JSON String in canonical format, conforming to [RFC 4122](https://tools.ietf.org/html/rfc4122), that is restricted by a regular expression for interoperability reasons. A UUID is always 36 characters long, 32 hexadecimal symbols and 4 dashes (‘-‘). */
    CorrelationId: string;
    /** The API data type DateTime is a JSON String in a lexical format that is restricted by a regular expression for interoperability reasons. The format is according to [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html), expressed in a combined date, time and time zone format. A more readable version of the format is yyyy-MM-ddTHH:mm:ss.SSS[-HH:MM]. Examples are "2016-05-24T08:38:08.699-04:00", "2016-05-24T08:38:08.699Z" (where Z indicates Zulu time zone, same as UTC). */
    DateTime: string;
    /** The API data type Latitude is a JSON String in a lexical format that is restricted by a regular expression for interoperability reasons. */
    Latitude: string;
    /** The API data type Longitude is a JSON String in a lexical format that is restricted by a regular expression for interoperability reasons. */
    Longitude: string;
    /** Data model for the complex type GeoCode. Indicates the geographic location from where the transaction was initiated. */
    GeoCode: {
      latitude: components['schemas']['Latitude'];
      longitude: components['schemas']['Longitude'];
    };
    /** Information for recipient (transport layer information). */
    IlpPacket: string;
    /** Condition that must be attached to the transfer by the Payer. */
    IlpCondition: string;
    /** The object sent in the PUT /quotes/{ID} callback. */
    QuotesIDPutResponse: {
      transferAmount: components['schemas']['Money'];
      payeeReceiveAmount?: components['schemas']['Money'];
      payeeFspFee?: components['schemas']['Money'];
      payeeFspCommission?: components['schemas']['Money'];
      expiration: components['schemas']['DateTime'];
      geoCode?: components['schemas']['GeoCode'];
      ilpPacket: components['schemas']['IlpPacket'];
      condition: components['schemas']['IlpCondition'];
      extensionList?: components['schemas']['ExtensionList'];
    };
    /** POST /authorizations Request object */
    AuthorizationsRequest: {
      toParticipantId?: string;
      authenticationType: components['schemas']['AuthenticationType'];
      retriesLeft: components['schemas']['Integer'];
      amount: components['schemas']['Money'];
      transactionId: components['schemas']['CorrelationId'];
      transactionRequestId: components['schemas']['CorrelationId'];
      quote: components['schemas']['QuotesIDPutResponse'];
    };
    /** The API data type OtpValue is a JSON String of 3 to 10 characters, consisting of digits only. Negative numbers are not allowed. One or more leading zeros are allowed. */
    OtpValue: string;
    /** QR code used as a One Time Password. */
    QRCODE: string;
    /** U2F challenge-response, where payer FSP verifies if the response provided by end-user device matches the previously registered key. */
    U2FPIN: string;
    /** U2F challenge-response, where payer FSP verifies if the response provided by end-user device matches the previously registered key. */
    U2FPinValue: {
      /** U2F challenge-response. */
      pinValue: components['schemas']['U2FPIN'];
      /** Sequential counter used for cloning detection. Present only for U2F authentication. */
      counter: components['schemas']['Integer'];
    };
    /** Contains the authentication value. The format depends on the authentication type used in the AuthenticationInfo complex type. */
    AuthenticationValue: Partial<components['schemas']['OtpValue']> &
    Partial<components['schemas']['QRCODE']> &
    Partial<components['schemas']['U2FPinValue']>;
    /** Data model for the complex type AuthenticationInfo. */
    AuthenticationInfo: {
      authentication: components['schemas']['AuthenticationType'];
      authenticationValue: components['schemas']['AuthenticationValue'];
    };
    /**
     * Below are the allowed values for the enumeration.
     * - ENTERED - Consumer entered the authentication value.
     * - REJECTED - Consumer rejected the transaction.
     * - RESEND - Consumer requested to resend the authentication value.
     */
    AuthorizationResponse: 'ENTERED' | 'REJECTED' | 'RESEND';
    /** state of POST authorizations */
    AuthorizationsState:
    | 'WAITING_FOR_AUTHORIZATION_REQUEST'
    | 'COMPLETED'
    | 'ERROR_OCCURRED';
    /**
     * This is a variant based on FSPIOP `PartyIdType` specification.
     * Main difference being the CONSENT and THIRD_PARTY_LINK enums.
     *
     * Below are the allowed values for the enumeration.
     * - MSISDN - An MSISDN (Mobile Station International Subscriber Directory
     * Number, that is, the phone number) is used as reference to a participant.
     * The MSISDN identifier should be in international format according to the
     * [ITU-T E.164 standard](https://www.itu.int/rec/T-REC-E.164/en).
     * Optionally, the MSISDN may be prefixed by a single plus sign, indicating the
     * international prefix.
     * - EMAIL - An email is used as reference to a
     * participant. The format of the email should be according to the informational
     * [RFC 3696](https://tools.ietf.org/html/rfc3696).
     * - PERSONAL_ID - A personal identifier is used as reference to a participant.
     * Examples of personal identification are passport number, birth certificate
     * number, and national registration number. The identifier number is added in
     * the PartyIdentifier element. The personal identifier type is added in the
     * PartySubIdOrType element.
     * - BUSINESS - A specific Business (for example, an organization or a company)
     * is used as reference to a participant. The BUSINESS identifier can be in any
     * format. To make a transaction connected to a specific username or bill number
     * in a Business, the PartySubIdOrType element should be used.
     * - DEVICE - A specific device (for example, a POS or ATM) ID connected to a
     * specific business or organization is used as reference to a Party.
     * For referencing a specific device under a specific business or organization,
     * use the PartySubIdOrType element.
     * - ACCOUNT_ID - A bank account number or FSP account ID should be used as
     * reference to a participant. The ACCOUNT_ID identifier can be in any format,
     * as formats can greatly differ depending on country and FSP.
     * - IBAN - A bank account number or FSP account ID is used as reference to a
     * participant. The IBAN identifier can consist of up to 34 alphanumeric
     * characters and should be entered without whitespace.
     * - ALIAS An alias is used as reference to a participant. The alias should be
     * created in the FSP as an alternative reference to an account owner.
     * Another example of an alias is a username in the FSP system.
     * The ALIAS identifier can be in any format. It is also possible to use the
     * PartySubIdOrType element for identifying an account under an Alias defined
     * by the PartyIdentifier.
     * - CONSENT - TBD
     * - THIRD_PARTY_LINK - TBD
     */
    PartyIdType:
    | 'MSISDN'
    | 'EMAIL'
    | 'PERSONAL_ID'
    | 'BUSINESS'
    | 'DEVICE'
    | 'ACCOUNT_ID'
    | 'IBAN'
    | 'ALIAS'
    | 'CONSENT'
    | 'THIRD_PARTY_LINK';
    /** Identifier of the Party. */
    PartyIdentifier: string;
    /** Either a sub-identifier of a PartyIdentifier, or a sub-type of the PartyIdType, normally a PersonalIdentifierType. */
    PartySubIdOrType: string;
    /** FSP identifier. */
    FspId: string;
    /** Data model for the complex type PartyIdInfo. */
    PartyIdInfo: {
      partyIdType: components['schemas']['PartyIdType'];
      partyIdentifier: components['schemas']['PartyIdentifier'];
      partySubIdOrType?: components['schemas']['PartySubIdOrType'];
      fspId?: components['schemas']['FspId'];
      extensionList?: components['schemas']['ExtensionList'];
    };
    /** ThirdpartyTransaction partyLookup request */
    ThirdpartyTransactionPartyLookupRequest: {
      payee: components['schemas']['PartyIdInfo'];
      transactionRequestId: components['schemas']['CorrelationId'];
    };
    /** state of thirdparty transaction partyLookup phase */
    ThirdpartyTransactionPartyLookupState:
    | 'start'
    | 'partyLookupSuccess'
    | 'partyLookupFailure'
    | 'errored';
    ThirdpartyTransactionPartyLookupResponseError: {
      currentState: components['schemas']['ThirdpartyTransactionPartyLookupState'];
      errorInformation: components['schemas']['ErrorInformation'];
    };
    /** A limited set of pre-defined numbers. This list would be a limited set of numbers identifying a set of popular merchant types like School Fees, Pubs and Restaurants, Groceries, etc. */
    MerchantClassificationCode: string;
    /** Name of the Party. Could be a real name or a nickname. */
    PartyName: string;
    /** First name of the Party (Name Type). */
    FirstName: string;
    /** Middle name of the Party (Name Type). */
    MiddleName: string;
    /** Last name of the Party (Name Type). */
    LastName: string;
    /** Data model for the complex type PartyComplexName. */
    PartyComplexName: {
      firstName?: components['schemas']['FirstName'];
      middleName?: components['schemas']['MiddleName'];
      lastName?: components['schemas']['LastName'];
    };
    /** Date of Birth of the Party. */
    DateOfBirth: string;
    /** Data model for the complex type PartyPersonalInfo. */
    PartyPersonalInfo: {
      complexName?: components['schemas']['PartyComplexName'];
      dateOfBirth?: components['schemas']['DateOfBirth'];
    };
    /**
     * A long-lived unique account identifier provided by the DFSP. This MUST NOT
     * be Bank Account Number or anything that may expose a User's private bank
     * account information.
     */
    AccountAddress: string;
    /**
     * The API data type Name is a JSON String, restricted by a regular expression to avoid characters which are generally not used in a name.
     *
     * Regular Expression - The regular expression for restricting the Name type is "^(?!\s*$)[\w .,'-]{1,128}$". The restriction does not allow a string consisting of whitespace only, all Unicode characters are allowed, as well as the period (.) (apostrophe (‘), dash (-), comma (,) and space characters ( ).
     *
     * **Note:** In some programming languages, Unicode support must be specifically enabled. For example, if Java is used, the flag UNICODE_CHARACTER_CLASS must be enabled to allow Unicode characters.
     */
    Name: string;
    /** Data model for the complex type Account. */
    Account: {
      address?: components['schemas']['AccountAddress'];
      currency: components['schemas']['Currency'];
      description?: components['schemas']['Name'];
    };
    /** Data model for the complex type AccountList. */
    AccountList: {
      /** Accounts associated with the Party. */
      account: components['schemas']['Account'][];
    };
    ThirdpartyTransactionPartyLookupResponseSuccess: {
      currentState: components['schemas']['ThirdpartyTransactionPartyLookupState'];
      party: {
        partyIdInfo?: components['schemas']['PartyIdInfo'];
        merchantClassificationCode?: components['schemas']['MerchantClassificationCode'];
        name?: components['schemas']['PartyName'];
        personalInfo?: components['schemas']['PartyPersonalInfo'];
        accounts?: components['schemas']['AccountList'];
      };
    };
    ThirdpartyTransactionPartyLookupResponse:
    | components['schemas']['ThirdpartyTransactionPartyLookupResponseError']
    | components['schemas']['ThirdpartyTransactionPartyLookupResponseSuccess'];
    /** Data model for the complex type Party. */
    Party: {
      accounts?: components['schemas']['AccountList'];
      partyIdInfo: components['schemas']['PartyIdInfo'];
      merchantClassificationCode?: components['schemas']['MerchantClassificationCode'];
      name?: components['schemas']['PartyName'];
      personalInfo?: components['schemas']['PartyPersonalInfo'];
    };
    /**
     * This is a variant based on FSPIOP `PartyIdType` specification.
     * This validation interface should be use by `POST /thirdpartyRequests/transactions`
     * - THIRD_PARTY_LINK - is the DFSP's internal reference which allows DFSP to find out the corresponding consent
     */
    PartyIdTypeTPLink: 'THIRD_PARTY_LINK';
    /** Data model for the complex type PartyIdInfo. */
    PartyIdInfoTPLink: {
      partyIdType: components['schemas']['PartyIdTypeTPLink'];
      partyIdentifier: components['schemas']['PartyIdentifier'];
      partySubIdOrType?: components['schemas']['PartySubIdOrType'];
      fspId?: components['schemas']['FspId'];
      extensionList?: components['schemas']['ExtensionList'];
    };
    /**
     * Below are the allowed values for the enumeration AmountType.
     * - SEND - Amount the Payer would like to send, that is, the amount that should be withdrawn from the Payer account including any fees.
     * - RECEIVE - Amount the Payer would like the Payee to receive, that is, the amount that should be sent to the receiver exclusive of any fees.
     */
    AmountType: 'SEND' | 'RECEIVE';
    /**
     * Below are the allowed values for the enumeration.
     * - DEPOSIT - Used for performing a Cash-In (deposit) transaction. In a normal scenario, electronic funds are transferred from a Business account to a Consumer account, and physical cash is given from the Consumer to the Business User.
     * - WITHDRAWAL - Used for performing a Cash-Out (withdrawal) transaction. In a normal scenario, electronic funds are transferred from a Consumer’s account to a Business account, and physical cash is given from the Business User to the Consumer.
     * - TRANSFER - Used for performing a P2P (Peer to Peer, or Consumer to Consumer) transaction.
     * - PAYMENT - Usually used for performing a transaction from a Consumer to a Merchant or Organization, but could also be for a B2B (Business to Business) payment. The transaction could be online for a purchase in an Internet store, in a physical store where both the Consumer and Business User are present, a bill payment, a donation, and so on.
     * - REFUND - Used for performing a refund of transaction.
     */
    TransactionScenario:
    | 'DEPOSIT'
    | 'WITHDRAWAL'
    | 'TRANSFER'
    | 'PAYMENT'
    | 'REFUND';
    /** Possible sub-scenario, defined locally within the scheme (UndefinedEnum Type). */
    TransactionSubScenario: string;
    /**
     * Below are the allowed values for the enumeration.
     * - PAYER - Sender of funds is initiating the transaction. The account to send from is either owned by the Payer or is connected to the Payer in some way.
     * - PAYEE - Recipient of the funds is initiating the transaction by sending a transaction request. The Payer must approve the transaction, either automatically by a pre-generated OTP or by pre-approval of the Payee, or by manually approving in his or her own Device.
     */
    TransactionInitiator: 'PAYER' | 'PAYEE';
    /**
     * Below are the allowed values for the enumeration.
     * - CONSUMER - Consumer is the initiator of the transaction.
     * - AGENT - Agent is the initiator of the transaction.
     * - BUSINESS - Business is the initiator of the transaction.
     * - DEVICE - Device is the initiator of the transaction.
     */
    TransactionInitiatorType: 'CONSUMER' | 'AGENT' | 'BUSINESS' | 'DEVICE';
    /** Reason for the refund. */
    RefundReason: string;
    /** Data model for the complex type Refund. */
    Refund: {
      originalTransactionId: components['schemas']['CorrelationId'];
      refundReason?: components['schemas']['RefundReason'];
    };
    /** (BopCode) The API data type [BopCode](https://www.imf.org/external/np/sta/bopcode/) is a JSON String of 3 characters, consisting of digits only. Negative numbers are not allowed. A leading zero is not allowed. */
    BalanceOfPayments: string;
    /** Data model for the complex type TransactionType. */
    TransactionType: {
      scenario: components['schemas']['TransactionScenario'];
      subScenario?: components['schemas']['TransactionSubScenario'];
      initiator: components['schemas']['TransactionInitiator'];
      initiatorType: components['schemas']['TransactionInitiatorType'];
      refundInfo?: components['schemas']['Refund'];
      balanceOfPayments?: components['schemas']['BalanceOfPayments'];
    };
    /** The object sent in the POST `/thirdpartyTransaction/{ID}/initiate` request. */
    ThirdpartyTransactionIDInitiateRequest: {
      payee: components['schemas']['Party'];
      payer: components['schemas']['PartyIdInfoTPLink'];
      amountType: components['schemas']['AmountType'];
      amount: components['schemas']['Money'];
      transactionType: components['schemas']['TransactionType'];
      expiration: string;
    };
    /** state of thirdparty transaction for initiate phase */
    ThirdpartyTransactionIDInitiateState:
    | 'partyLookupSuccess'
    | 'authorizationReceived'
    | 'errored';
    ThirdpartyTransactionIDInitiateResponseError: {
      currentState: components['schemas']['ThirdpartyTransactionIDInitiateState'];
      errorInformation: components['schemas']['ErrorInformation'];
    };
    /** POST /authorizations request object. */
    AuthorizationsPostRequest: {
      authenticationType: components['schemas']['AuthenticationType'];
      retriesLeft: components['schemas']['Integer'];
      amount: components['schemas']['Money'];
      transactionId: components['schemas']['CorrelationId'];
      transactionRequestId: components['schemas']['CorrelationId'];
      quote: components['schemas']['QuotesIDPutResponse'];
    };
    ThirdpartyTransactionIDInitiateResponseSuccess: {
      currentState: components['schemas']['ThirdpartyTransactionIDInitiateState'];
      authorization: components['schemas']['AuthorizationsPostRequest'];
    };
    ThirdpartyTransactionIDInitiateResponse:
    | components['schemas']['ThirdpartyTransactionIDInitiateResponseError']
    | components['schemas']['ThirdpartyTransactionIDInitiateResponseSuccess'];
    /** The object sent in the PUT /authorizations/{ID} callback. */
    AuthorizationsIDPutResponse: {
      authenticationInfo?: components['schemas']['AuthenticationInfo'];
      responseType: components['schemas']['AuthorizationResponse'];
    };
    ThirdpartyTransactionIDApproveRequest: {
      authorizationResponse: components['schemas']['AuthorizationsIDPutResponse'];
    };
    /** state of thirdparty transaction */
    ThirdpartyTransactionIDApproveState:
    | 'authorizationReceived'
    | 'transactionStatusReceived'
    | 'errored';
    ThirdpartyTransactionIDApproveResponseError: {
      currentState: components['schemas']['ThirdpartyTransactionIDApproveState'];
      errorInformation: components['schemas']['ErrorInformation'];
    };
    /**
     * Below are the allowed values for the enumeration.
     * - RECEIVED - Payer FSP has received the transaction from the Payee FSP.
     * - PENDING - Payer FSP has sent the transaction request to the Payer.
     * - ACCEPTED - Payer has approved the transaction.
     * - REJECTED - Payer has rejected the transaction.
     */
    TransactionRequestState: 'RECEIVED' | 'PENDING' | 'ACCEPTED' | 'REJECTED';
    ThirdpartyTransactionIDApproveResponseSuccess: {
      transactionStatus: {
        transactionId: components['schemas']['CorrelationId'];
        transactionRequestState: components['schemas']['TransactionRequestState'];
      };
      currentState: components['schemas']['ThirdpartyTransactionIDApproveState'];
    };
    ThirdpartyTransactionIDApproveResponse:
    | components['schemas']['ThirdpartyTransactionIDApproveResponseError']
    | components['schemas']['ThirdpartyTransactionIDApproveResponseSuccess'];
    /** The API data type BinaryString is a JSON String. The string is a base64url  encoding of a string of raw bytes, where padding (character ‘=’) is added at the end of the data if needed to ensure that the string is a multiple of 4 characters. The length restriction indicates the allowed number of characters. */
    BinaryString: string;
    /** The object sent in the POST /thirdpartyRequests/transactions/{id}/authorizations request. */
    ThirdpartyRequestsTransactionsIDAuthorizationsPostRequest: {
      /** Base64 encoded binary string - the original challenge. */
      challenge: string;
      /** Base64 encoded binary string - the signed challenge */
      value: components['schemas']['BinaryString'];
      /** Common ID between the PISP and FSP for the Consent object This tells DFSP and auth-service which constent allows the PISP to initiate transaction. */
      consentId: components['schemas']['CorrelationId'];
      /** DFSP specific account identifiers, e.g. `dfspa.alice.1234` */
      sourceAccountId: components['schemas']['AccountAddress'];
      /** The status of the authorization. This MUST be PENDING for a POST request */
      status: 'PENDING';
    };
    /** The object sent in the PUT /thirdpartyRequests/transactions/{id}/authorizations request. */
    ThirdpartyRequestsTransactionsIDAuthorizationsPutResponse: {
      /** Base64 encoded binary string - the original challenge. */
      challenge: string;
      /** Base64 encoded binary string - the signed challenge. */
      value: components['schemas']['BinaryString'];
      /** Common ID between the PISP and FSP for the Consent object This tells DFSP and auth-service which consent allows the PISP to initiate transaction. */
      consentId: components['schemas']['CorrelationId'];
      /** DFSP specific account identifiers, e.g. `dfspa.alice.1234` */
      sourceAccountId: components['schemas']['AccountAddress'];
      /** The status of the authorization. This value must be `VERIFIED` for a PUT request. */
      status: 'VERIFIED';
    };
    AccountsIDPutResponse: {
      accountNickname: components['schemas']['AccountAddress'];
      id: components['schemas']['AccountAddress'];
      currency: components['schemas']['Currency'];
    }[];
    /** POST /consentRequests/{ID}/validate Request object */
    ConsentRequestsValidateRequest: {
      toParticipantId: string;
      authToken: string;
    };
    /** State of POST consent requests validate */
    ConsentRequestsValidateState:
    | 'start'
    | 'errored'
    | 'success'
    | 'OTPIsValid';
    ConsentRequestsValidateResponseError: {
      errorInformation: components['schemas']['ErrorInformation'];
      currentState: components['schemas']['ConsentRequestsValidateState'];
    };
    /**
     * The scopes requested for a ConsentRequest.
     * - "accounts.getBalance" - Get the balance of a given account.
     * - "accounts.transfer" - Initiate a transfer from an account.
     */
    ConsentScopeType: 'accounts.getBalance' | 'accounts.transfer';
    /** Scope + Account Identifier mapping for a Consent. */
    Scope: {
      accountId: components['schemas']['AccountAddress'];
      actions: components['schemas']['ConsentScopeType'][];
    };
    /** The object sent in a `POST /consents` request. */
    ConsentsPostRequest: {
      /**
       * Common ID between the PISP and FSP for the Consent object
       * decided by the DFSP who creates the Consent
       * This field is REQUIRED for POST /consent.
       */
      consentId: components['schemas']['CorrelationId'];
      /**
       * The id of the ConsentRequest that was used to initiate the
       * creation of this Consent.
       */
      consentRequestId: components['schemas']['CorrelationId'];
      scopes: components['schemas']['Scope'][];
    };
    ConsentRequestsValidateResponseSuccess: {
      consent: components['schemas']['ConsentsPostRequest'];
      currentState: components['schemas']['ConsentRequestsValidateState'];
    };
    ConsentRequestsValidateResponse:
    | components['schemas']['ConsentRequestsValidateResponseError']
    | components['schemas']['ConsentRequestsValidateResponseSuccess'];
    /**
     * The auth channel being used for the consentRequest.
     * - "WEB" - The Web auth channel.
     * - "OTP" - The OTP auth channel.
     */
    ConsentRequestChannelType: 'WEB' | 'OTP';
    /** The object sent in a `POST /consentRequests` request. */
    ConsentRequestsPostRequest: {
      toParticipantId: string;
      id: components['schemas']['CorrelationId'];
      /** The id of the PISP who will initiate transactions on a user's behalf. */
      initiatorId: string;
      scopes: components['schemas']['Scope'][];
      authChannels: components['schemas']['ConsentRequestChannelType'][];
      /** The callback uri that the user will be redirected to after completing the WEB auth channel. */
      callbackUri: string;
    };
    /** State of POST consent requests */
    ConsentRequestsState: 'start' | 'errored' | 'success' | 'RequestIsValid';
    ConsentRequestsResponseError: {
      errorInformation: components['schemas']['ErrorInformation'];
      currentState: components['schemas']['ConsentRequestsState'];
    };
    /** The web auth channel being used for PUT consentRequest/{ID} request. */
    ConsentRequestChannelTypeWeb: 'WEB';
    /**
     * The object sent in a `PUT /consentRequests/{ID}` request.
     *
     * Schema used in the request consent phase of the account linking web flow,
     * the result is the PISP being instructed on a specific URL where this
     * supposed user should be redirected. This URL should be a place where
     * the user can prove their identity (e.g., by logging in).
     */
    ConsentRequestsIDPutResponseWeb: {
      /** The id of the PISP who will initiate transactions on a user's behalf. */
      initiatorId: string;
      scopes: components['schemas']['Scope'][];
      authChannels: components['schemas']['ConsentRequestChannelTypeWeb'][];
      /** The callback uri that the user will be redirected to after completing the WEB auth channel. */
      callbackUri: string;
      /** The callback uri that the pisp app redirects to for user to complete their login. */
      authUri: string;
    };
    /**
     * The object sent in a `PUT /consentRequests/{ID}` request.
     *
     * Schema used in the authentication phase of the account linking flow,
     * the user is expected to prove their identity to the DFSP by passing a OTP
     * or secret to the PISP.
     */
    ConsentRequestsIDPutResponseWebAuth: {
      /** The id of the PISP who will initiate transactions on a user's behalf. */
      initiatorId: string;
      scopes: components['schemas']['Scope'][];
      authChannels: components['schemas']['ConsentRequestChannelTypeWeb'][];
      /** The callback uri that the user will be redirected to after completing the WEB auth channel. */
      callbackUri: string;
      /** The callback uri that the pisp app redirects to for user to complete their login. */
      authUri: string;
      /** The Auth token from the OTP or redirect to pisp app. */
      authToken: string;
    };
    /** The OTP auth channel being used for PUT consentRequest/{ID} request. */
    ConsentRequestChannelTypeOTP: 'OTP';
    /**
     * The object sent in a `PUT /consentRequests/{ID}` request.
     *
     * Schema used in the request consent phase of the account linking OTP/SMS flow.
     */
    ConsentRequestsIDPutResponseOTP: {
      /** The id of the PISP who will initiate transactions on a user's behalf. */
      initiatorId: string;
      scopes: components['schemas']['Scope'][];
      authChannels: components['schemas']['ConsentRequestChannelTypeOTP'][];
      /** The callback uri that the user will be redirected to after completing the WEB auth channel. */
      callbackUri: string;
    };
    /**
     * The object sent in a `PUT /consentRequests/{ID}` request.
     *
     * Schema used in the authentication phase of the account linking flow,
     * the user is expected to prove their identity to the DFSP by passing a OTP
     * or secret to the PISP.
     */
    ConsentRequestsIDPutResponseOTPAuth: {
      /** The id of the PISP who will initiate transactions on a user's behalf. */
      initiatorId: string;
      scopes: components['schemas']['Scope'][];
      authChannels: components['schemas']['ConsentRequestChannelTypeOTP'][];
      /** The callback uri that the user will be redirected to after completing the WEB auth channel. */
      callbackUri: string;
      /** The Auth token from the OTP or redirect to pisp app. */
      authToken: string;
    };
    ConsentRequestsResponseSuccess: {
      consentRequests:
      | components['schemas']['ConsentRequestsIDPutResponseWeb']
      | components['schemas']['ConsentRequestsIDPutResponseWebAuth']
      | components['schemas']['ConsentRequestsIDPutResponseOTP']
      | components['schemas']['ConsentRequestsIDPutResponseOTPAuth'];
      currentState: components['schemas']['ConsentRequestsState'];
    };
    ConsentRequestsResponse:
    | components['schemas']['ConsentRequestsResponseError']
    | components['schemas']['ConsentRequestsResponseSuccess'];
    /** State of GET /linking/providers request */
    LinkingProvidersState: 'start' | 'errored' | 'providersLookupSuccess';
    LinkingProvidersResponseError: {
      errorInformation: components['schemas']['ErrorInformation'];
      currentState: components['schemas']['LinkingProvidersState'];
    };
    /** The object sent in a `PUT /services/{ServiceType}` request. */
    ServicesServiceTypePutResponse: {
      providers: components['schemas']['FspId'][];
    };
    LinkingProvidersResponseSuccess: {
      providers: components['schemas']['ServicesServiceTypePutResponse'];
      currentState: components['schemas']['LinkingProvidersState'];
    };
    LinkingProvidersResponse:
    | components['schemas']['LinkingProvidersResponseError']
    | components['schemas']['LinkingProvidersResponseSuccess'];
  };
  responses: {
    /** OK */
    '200': {};
    /** Bad Request */
    '400': {
      content: {
        'application/json': components['schemas']['ErrorInformationResponse'];
      };
      headers: {
        'Content-Length': components['headers']['Content-Length'];
        'Content-Type': components['headers']['Content-Type'];
      };
    };
    /** Unauthorized */
    '401': {
      content: {
        'application/json': components['schemas']['ErrorInformationResponse'];
      };
      headers: {
        'Content-Length': components['headers']['Content-Length'];
        'Content-Type': components['headers']['Content-Type'];
      };
    };
    /** Forbidden */
    '403': {
      content: {
        'application/json': components['schemas']['ErrorInformationResponse'];
      };
      headers: {
        'Content-Length': components['headers']['Content-Length'];
        'Content-Type': components['headers']['Content-Type'];
      };
    };
    /** Not Found */
    '404': {
      content: {
        'application/json': components['schemas']['ErrorInformationResponse'];
      };
      headers: {
        'Content-Length': components['headers']['Content-Length'];
        'Content-Type': components['headers']['Content-Type'];
      };
    };
    /** Method Not Allowed */
    '405': {
      content: {
        'application/json': components['schemas']['ErrorInformationResponse'];
      };
      headers: {
        'Content-Length': components['headers']['Content-Length'];
        'Content-Type': components['headers']['Content-Type'];
      };
    };
    /** Not Acceptable */
    '406': {
      content: {
        'application/json': components['schemas']['ErrorInformationResponse'];
      };
      headers: {
        'Content-Length': components['headers']['Content-Length'];
        'Content-Type': components['headers']['Content-Type'];
      };
    };
    /** Not Implemented */
    '501': {
      content: {
        'application/json': components['schemas']['ErrorInformationResponse'];
      };
      headers: {
        'Content-Length': components['headers']['Content-Length'];
        'Content-Type': components['headers']['Content-Type'];
      };
    };
    /** Service Unavailable */
    '503': {
      content: {
        'application/json': components['schemas']['ErrorInformationResponse'];
      };
      headers: {
        'Content-Length': components['headers']['Content-Length'];
        'Content-Type': components['headers']['Content-Type'];
      };
    };
    /**
     * response body of POST/authorizations
     * derived from AuthorizationsIDPutResponse by Inbound Service via Pub/Sub channel
     */
    AuthorizationsResponse: {
      content: {
        'application/json': {
          authenticationInfo?: components['schemas']['AuthenticationInfo'];
          responseType: components['schemas']['AuthorizationResponse'];
          currentState?: components['schemas']['AuthorizationsState'];
        };
      };
    };
    /** ThirdpartyTransaction partyLookup response */
    ThirdpartyTransactionPartyLookupResponse: {
      content: {
        'application/json': components['schemas']['ThirdpartyTransactionPartyLookupResponse'];
      };
    };
    /** ThirdpartyTransactionIDInitiate response */
    ThirdpartyTransactionIDInitiateResponse: {
      content: {
        'application/json': components['schemas']['ThirdpartyTransactionIDInitiateResponse'];
      };
    };
    /** ThirdpartyTransactionIDApproveResponse */
    ThirdpartyTransactionIDApproveResponse: {
      content: {
        'application/json': components['schemas']['ThirdpartyTransactionIDApproveResponse'];
      };
    };
    /** Thirdparty requests transactions authorizations response */
    ThirdpartyRequestsTransactionsIDAuthzResponse: {
      content: {
        'application/json': components['schemas']['ThirdpartyRequestsTransactionsIDAuthorizationsPutResponse'];
      };
    };
    /**
     * response body of GET /accounts/{ID}
     * derived from UpdateAccountsByUserId by Inbound Service via Pub/Sub channel
     */
    AccountsByUserIdResponse: {
      content: {
        'application/json': components['schemas']['AccountsIDPutResponse'];
      };
    };
    /** Consent requests validate response */
    ConsentRequestsValidateResponse: {
      content: {
        'application/json': components['schemas']['ConsentRequestsValidateResponse'];
      };
    };
    /**
     * response body of POST /consentRequests
     * derived from PostConsentRequest by Inbound Service via Pub/Sub channel
     */
    ConsentRequestsResponse: {
      content: {
        'application/json': components['schemas']['ConsentRequestsResponse'];
      };
    };
    /** Response body of GET /linking/providers */
    LinkingProvidersResponse: {
      content: {
        'application/json': components['schemas']['LinkingProvidersResponse'];
      };
    };
  };
}
